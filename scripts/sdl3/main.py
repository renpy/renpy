import argparse
import ast
import collections
import pathlib
import re

from Cython.Shadow import typedef

try:
    from clang import cindex
    from clang.cindex import CursorKind
except ImportError as e:
    print("ERROR: libclang Python bindings not available (install libclang)", file=sys.stderr)
    raise


class Generator:
    def __init__(self, sdl3_path: pathlib.Path):
        """
        `sdl3_path`
            The path to the SDL3 directory.
        """

        self.sdl3_path: pathlib.Path = sdl3_path

        self.declarations: list[tuple[pathlib.Path, str]] = []
        """
        Aa list of (header, declaration_text) tuples.
        """

        self.declared_names = set()

        self.enum_values: dict[str, list[str]] = collections.defaultdict(list)

        self.macros = list()

    def clear(self):
        """
        Clears names that may have been declared elsewhere.
        """
        self.declarations.clear()
        self.enum_values.clear()
        self.macros.clear()

    def declare(self, cursor: cindex.Cursor, decl: str):
        """
        Add a declaration to the list of declarations.

        `cursor`
            The cursor that corresponds to the declaration.
        `decl`
            The declaration text.
        """

        if cursor.location.file is None:
            return

        try:
            header = pathlib.Path(cursor.location.file.name).relative_to(self.sdl3_path)
            self.declarations.append((header, decl))
        except ValueError:
            pass

    def generate(self, destination_pxd: pathlib.Path, destination_pyx: pathlib.Path):
        old_header: pathlib.Path | None = None

        with open(destination_pxd, "w") as f:
            print(
                """
# This file is automatically generated by scripts/sdl3/main.py. Do not edit manually.

""",
                file=f,
            )

            print("from libc.stdint cimport *", file=f)
            print("from libc.stddef cimport wchar_t", file=f)
            print("from libcpp cimport bool as cbool", file=f)
            print("ctypedef struct va_list", file=f)
            print(file=f)

            print('cdef extern from "SDL3/SDL.h" nogil:', file=f)

            for header, decl in self.declarations:
                if header != old_header:
                    print(file=f)
                    print(f"    # Definitions from {header}", file=f)

                    old_header = header

                print(decl, file=f)

            print(file=f)
            print("    int SDL_MUSTLOCK(SDL_Surface *surface)", file=f)

            print(file=f)
            print("    cdef enum:", file=f)
            for macro in self.macros:
                print(f"        {macro}", file=f)

        self.declarations.clear()
        self.macros.clear()

        with open(destination_pyx, "w") as f:
            print(
                """
# This file is automatically generated by scripts/sdl3/main.py. Do not edit manually.
""",
                file=f,
            )

            for enum_name, enum_values in sorted(self.enum_values.items()):
                if not enum_name.startswith("SDL_"):
                    continue

                lower_enum_name = enum_name.lower()

                print(file=f)
                print(f"{lower_enum_name}_enum = {{", file=f)

                for value in enum_values:
                    if value.startswith("SDL_"):
                        print(f"    '{value}': {value},", file=f)

                print("    }", file=f)

    def is_relevant(self, node: cindex.Cursor) -> bool:
        """
        Returns True if the node exists in the SDL3 directory, False otherwise. T
        """

        if node.location.file is None:
            return False

        return pathlib.Path(node.location.file.name).is_relative_to(self.sdl3_path)

    def check_new_name(self, name: str) -> bool:
        """
        Check if the name has already been declared. If not, add it to the set of declared names.

        `name`
            The name to check.

        Returns True if the name is new, False otherwise.
        """

        if name in self.declared_names:
            return False

        self.declared_names.add(name)
        return True

    def enum(self, node: cindex.Cursor):
        if not self.is_relevant(node):
            return

        if not self.check_new_name(node.spelling):
            return

        self.declare(node, f"    cdef enum {node.spelling}:")
        for child in node.get_children():
            if child.kind == CursorKind.ENUM_CONSTANT_DECL:
                self.declare(child, f"        {child.spelling}")
                self.enum_values[node.spelling].append(child.spelling)

    def elide_tokens(self, t: cindex.Cursor) -> str:
        tokens = t.get_tokens()
        parts = []
        for token in tokens:
            if token.spelling in {
                "extern",
                "typedef",
                "struct",
                "union",
                "enum",
                "__attribute__",
                "__extension__",
                "__inline__",
                "SDLCALL",
                "SDL_MALLOC",
                "SDL_DECLSPEC",
                "SDLMAIN_DECLSPEC",
                "SDL_SCANF_FORMAT_STRING",
                "SDL_PRINTF_FORMAT_STRING",
                "SDL_ANALYZER_NORETURN",
            }:
                continue

            if token.spelling == "bool":
                parts.append("cbool")
            else:
                parts.append(token.spelling)

        joined = " ".join(parts)

        joined = re.sub(r"SDL_ALLOC_SIZE2?\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_OUT_BYTECAP\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_IN_BYTECAP\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_OUT_Z_CAP\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_IN_Z_CAP\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_INOUT_Z_CAP\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_SCANF_VARARG_FUNC\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_SCANF_VARARG_FUNCV\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_PRINTF_VARARG_FUNC\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"SDL_PRINTF_VARARG_FUNCV\s*\(.*?\)\s*" , "", joined)
        joined = re.sub(r"\( ", "(", joined)
        joined = re.sub(r" \)", ")", joined)
        joined = re.sub(r"\) \(", ")(", joined)
        joined = re.sub(r" ,", ",", joined)
        joined = re.sub(r"\* ", "*", joined)
        joined = re.sub(r"\(void\)", "()", joined)


        joined = joined.replace("[ SDL_MESSAGEBOX_COLOR_COUNT ]", "[]")

        return joined

    def type_spelling(self, t: cindex.Type) -> str:
        spelling = t.spelling

        spelling = re.sub(r"\b(struct|union|enum)\b\s*", "", spelling)
        return spelling.strip()

    def function(self, node: cindex.Cursor):
        if not self.is_relevant(node):
            return

        name = node.spelling

        if not self.check_new_name(name):
            return

        sig = self.elide_tokens(node)

        # ret_type = node.result_type.spelling
        # params = []
        # for arg in node.get_arguments():

        #     params.append(self.elide_tokens(arg))

        # if ret_type.endswith("*"):
        #     sig = f"{ret_type}{name}({', '.join(params)})"
        # else:
        #     sig = f"{ret_type} {name}({', '.join(params)})"

        self.declare(node, f"    {sig}")

    def struct(self, node: cindex.Cursor):
        if not self.is_relevant(node):
            return

        if not self.check_new_name(node.spelling):
            return


        first_field = True
        has_fields = False

        if not node.spelling == "SDL_IOStreamInterface":
            for child in node.get_children():
                if child.kind == CursorKind.FIELD_DECL:

                    if first_field:
                        self.declare(node, f"    cdef struct {node.spelling}:")
                        first_field = False
                    self.declare(child, f"        {self.elide_tokens(child)}")
                    has_fields = True

        if not has_fields:
            self.declare(node, f"    cdef struct {node.spelling}")

    def union(self, node: cindex.Cursor):
        if not self.is_relevant(node):
            return

        if "unnamed at" in node.spelling:
            return

        if not self.check_new_name(node.spelling):
            return

        self.declare(node, f"    cdef union {node.spelling}:")

        has_fields = False

        for child in node.get_children():
            if child.kind == CursorKind.FIELD_DECL:
                self.declare(child, f"        {self.elide_tokens(child)}")
                has_fields = True

        if not has_fields:
            self.declare(node, f"        pass")

    extra_macros = {
        "SDL_WINDOWPOS_UNDEFINED",
        "SDL_WINDOWPOS_CENTERED",
        "SDL_BUTTON_LMASK",
        "SDL_BUTTON_MMASK",
        "SDL_BUTTON_RMASK",
        "SDL_BUTTON_X1MASK",
        "SDL_BUTTON_X2MASK",
    }

    def macro(self, node: cindex.Cursor):

        if not self.is_relevant(node):
            return

        if not node.spelling.startswith("SDL_") and not node.spelling.startswith("SDLK_"):
            return

        if node.spelling.startswith("SDL_PLATFORM_"):
            return

        if not self.check_new_name(node.spelling):
            return

        def clean_token(t: str) -> str:
            t = re.sub(r"(0x[\da-fA-F]+)[UuLl]*", r"\1", t)
            t = re.sub(r"(\d+)[lLuU]*", r"\1", t)
            return t.strip()

        tokens = [clean_token(t.spelling) for t in node.get_tokens()]
        tokens = tokens[1:]  # Skip the macro name.

        decl = "".join(tokens).strip()
        decl = re.sub(r"SDL_UINT64_C\((.*?)\)", r"\1", decl)

        if not decl:
            return

        try:
            value = ast.literal_eval(decl)
        except Exception:
            if node.spelling not in Generator.extra_macros:
                return
            value = -1 # Just to pass the test below.

        if isinstance(value, (str, int)):
            self.macros.append(node.spelling)


    def typedef(self, node: cindex.Cursor):
        if not self.is_relevant(node):
            return

        if not self.check_new_name(node.spelling):
            return

        decl = self.elide_tokens(node)

        if not decl.strip():
            self.declare(node, f"    # Skipping empty typedef {node.spelling}")
            return

        self.declare(node, f"    ctypedef {decl}")

    def before(self, node: cindex.Cursor, name: str):
        match name:
            # Cindex gets wrong.
            case "SDL_SetEventFilter":
                self.declare(node, "    ctypedef cbool (*SDL_EventFilter)(void *userdata, SDL_Event *event)")

            # Cindex gets wrong.
            case "SDL_SetX11EventHook":
                self.declare(node, "    ctypedef void (*SDL_X11EventHook)(void *userdata, XEvent *event)")

            # We don't support anonymous structs/unions.
            case "SDL_GetGamepadBindings":
                self.declare(node, """    ctypedef struct SDL_GamepadBinding""")

    def traverse(self, node: cindex.Cursor, depth: int):
        self.before(node, node.spelling)

        if node.spelling == "SDL_GamepadBinding":
            return

        # print("  " * depth, node.kind, node.location, repr(node.spelling)[:100])

        for child in node.get_children():
            self.traverse(child, depth + 1)

        if node.kind == CursorKind.FUNCTION_DECL:
            self.function(node)

        elif node.kind == CursorKind.TYPEDEF_DECL:
            self.typedef(node)

        elif node.kind == CursorKind.ENUM_DECL:
            self.enum(node)

        elif node.kind == CursorKind.STRUCT_DECL:
            self.struct(node)

        elif node.kind == CursorKind.UNION_DECL:
            self.union(node)

        elif node.kind == CursorKind.MACRO_DEFINITION:
            self.macro(node)


def main():
    ap = argparse.ArgumentParser(description="SDL3 Binding Generator")

    ap.add_argument("--early", nargs="*", help="Paths to any early header files to ignore definitions from.", type=pathlib.Path)
    ap.add_argument("header", nargs="*", help="Path to the header file.", type=pathlib.Path)
    ap.add_argument(
        "--destination",
        help="Path to the directory to which .pxd files will be written.",
        type=pathlib.Path,
        default=pathlib.Path("pygame"),
    )

    args = ap.parse_args()

    early_headers: list[pathlib.Path] = []
    "A list of early header files to ignore definitions from."

    if args.early:
        early_headers = [ i.absolute() for i in args.early ]

    headers: list[pathlib.Path] = [ i.absolute() for i in args.header ]
    "The path to the SDL3/SDL.h header file, made absolute."

    sdl3_path: pathlib.Path = headers[0].parent
    "If SDL3 is in /usr/include/SDL3/SDL.h, then sdl3_path is /usr/include/SDL3."

    include_dir: pathlib.Path = sdl3_path.parent
    "If SDL3 is in /usr/include/SDL3, then include_dir is /usr/include."

    generator = Generator(sdl3_path)

    index = cindex.Index.create()
    options = cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD
    index_args = [f"-I{include_dir}", "-DSDL_MAIN_HANDLED"]


    for i in early_headers:
        tu = index.parse(str(i), args=index_args, options=options)
        generator.traverse(tu.cursor, 0)

    generator.clear()

    for i in headers:
        tu = index.parse(str(i), args=index_args, options=options)
        generator.traverse(tu.cursor, 0)

    destination_pxd = args.destination / (headers[0].stem.lower() + ".pxd")
    "The path to the destination .pxd file."

    destination_pyx = args.destination / (headers[0].stem.lower() + ".pyx")

    generator.generate(destination_pxd, destination_pyx)


if __name__ == "__main__":
    main()
